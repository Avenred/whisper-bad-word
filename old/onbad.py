from threading import Thread
from colorama import Fore, Back, Cursor
import whisper
import sounddevice as sd
from scipy.io.wavfile import write
import os
from platform import system as system_os
import random
from time import sleep
import traceback

# ^^^^^^^^ import needed libraries


class BadFinder:
    endphrase = ""  # The phrase that ends the program
    catch = True  # the "catch_reg" variable in the "check" function. Any word containing the bad words will be caught.
    model: whisper.Whisper  # the model used by whisper
    transcribed = ""  # the transcribed output generated by whisper
    random_name = ""  # the name of last known output file from the microphone
    ready = False  # ready, check, and done are for communication between the threads
    done = False
    check = False

    Running = True  # for stopping the thread

    custom_file = ""  # the name of the custom file (if any)

    def __init__(
        self,
        custom_script_file: str = None,
        custom_script_str: str = None,
        use_custom: bool = True,
    ):
        self.custom_c = use_custom  # a bool to check if we're running custom code

        self.load_model()  # load the model and preform the setup
        self.setup()  # refer to lines 65-79

        if (
            system_os() == "Windows"
        ):  # depending on the operating system we use a different command to clear the screen
            os.system("cls")
        else:
            os.system("clear")

        if use_custom:  # if we're using a custom script we import it
            if custom_script_file != None:
                if custom_script_file.endswith(".py"):
                    self.bad_c = __import__(custom_script_file[0:-3])
                else:
                    raise ValueError("A python file must be used for a custom script.")
            elif (
                custom_script_str != None
            ):  # if the script provided is in a "str" and not a file on the disk we create a file and import it
                with open("Default_name.py", "a") as PythonScriptFile_mw:
                    PythonScriptFile_mw.close()
                with open("Default_name.py", "w") as PythonScriptFile:
                    PythonScriptFile.write(custom_script_str)
                    PythonScriptFile.close()
                self.bad_c = __import__("Default_name")
            else:
                raise ValueError(
                    "No script was specified."
                )  # if the "use_custom" variable is True but no input file or str is provided then raise an error
        else:
            pass

    # load model code
    def load_model(self):
        print("Model loading...")
        self.model = whisper.load_model("tiny.en")
        print("Loaded!\n")

    def setup(self):
        self.endphrase = input(
            "Saying the following phrase ends the program >>> "
        ).lower()  # get the end phrase from the user (in some cases the word can be impossible due to whisper ai's impeccable transcribing abilities)
        if self.endphrase == "":
            print("Using default phrase...")
            self.endphrase = "end"
        try:
            use_catch_reg = input(
                'Use fuzzy mode?\nAny word containing the bad words will be caught \nEx: "thing" will be caught in "anything"\ny/n >>> '  # if we want to use fuzzy mode
            )[0].lower()
        except IndexError:
            use_catch_reg = "n"
        self.custom_file = input(
            "If you have a custom set of bad words input the file name (leave blank to use the default) >>> "  # get custom bad words file
        )
        if self.custom_file == "":  # checking of inputs
            self.custom_file = "bad_words.txt"
        if use_catch_reg == "y":
            self.catch = True
        else:
            self.catch = False

    def whisper_transcribe(self):  # the thread that uses whisper to transcribe
        while self.Running:  # to stop the threads, this is in all thread functions
            if (
                self.done
            ):  # if the recording thread is finished then we open the file and start transcribing
                try:
                    print(
                        f"{Cursor.POS(1, 2)}Whisper Stauts: {Fore.BLACK}{Back.GREEN}Transcribing{Fore.RESET}{Back.RESET}"
                    )  # print status
                    #    print('Transcribing...')  # debug
                    # self.Running = False  # I'm DUMB as SHIT. I left in debug shit GOD FUCKING DAMMIT
                    result = self.model.transcribe(
                        self.random_name
                    )  # transcribe the audio and get the text
                    self.transcribed = str(result["text"])
                    # now delete the file
                    print(
                        f"{Cursor.POS(1, 2)}Whisper Stauts: {Fore.BLACK}{Back.GREEN}Removing old file...{Fore.RESET}{Back.RESET}"
                    )  # print status
                    os.remove(self.random_name)
                    print(
                        f"{Cursor.POS(1, 2)}Whisper Stauts: {Fore.BLACK}{Back.GREEN}Done.{Fore.RESET}{Back.RESET}"
                    )  # print status
                    print(
                        f"{Cursor.POS(1, 2)}Whisper Stauts: {Fore.BLACK}{Back.RED}Waiting{Fore.RESET}{Back.RESET}                  "
                    )  # update status
                    while self.check:
                        pass  # waits until the check thread is ready to accept the next string
                    self.ready = True  # update threads
                    self.done = False
                    self.check = True
                    print(
                        f"{Cursor.POS(1, 2)}Whisper Stauts: {Fore.BLACK}{Back.RED}Idle{Fore.RESET}{Back.RESET}            "
                    )
                except Exception as e:
                    self.Running = False
                    print(
                        f"{Cursor.POS(1, 4)}Whisper: {e}\n({traceback.format_exc().strip()})"
                    )  # if an error occurs this will stop the program, print the error, and where the error came from. This code is used in lines 100, 124, and 215
                    exit(1)
        print(Cursor.POS(1, 4))

    def record_and_save(
        self, duration: int = 10, sample_rate: int = 44100
    ):  # the thread that records the audio
        while self.Running:
            if self.ready:
                try:
                    print(
                        f"{Cursor.POS(1, 1)}Recording Stauts: {Fore.BLACK}{Back.GREEN}Recording{Fore.RESET}{Back.RESET}"
                    )  # update status
                    #    print("Recording...")  # debug
                    recording = sd.rec(
                        int(duration * sample_rate), samplerate=sample_rate, channels=2
                    )  # record
                    print(
                        f"{Cursor.POS(1, 1)}Recording Status: {Fore.BLACK}{Back.GREEN}Waiting{Fore.RESET}{Back.RESET}          "
                    )
                    sleep(
                        duration
                    )  # for some reason sd.wait() sucks dick and never works, so we use sleep() instead
                    #    print("Saving...")  # debug
                    # pick a random name for the file
                    if self.Running:
                        self.random_name = str(
                            random.randint(0, 999999999)
                        )  # generate the random name
                        print(
                            f"{Cursor.POS(1, 1)}Recording Status: {Fore.BLACK}{Back.GREEN}Saving{Fore.RESET}{Back.RESET}                "
                        )
                        write(
                            self.random_name, sample_rate, recording
                        )  # Save as WAV file
                        print(
                            f"{Cursor.POS(1, 1)}Recording Status: {Fore.BLACK}{Back.RED}Idle{Fore.RESET}{Back.RESET}              "
                        )
                    self.done = True  # update threads
                    self.ready = False
                except (
                    Exception
                ) as e:  # The bare exception is required as I don't know what errors can occur in each thread
                    self.Running = False
                    print(
                        f"{Cursor.POS(1, 4)}Whisper: {e}\n({traceback.format_exc().strip()})"
                    )
                    exit(1)
        print(Cursor.POS(1, 4))

    def bad_word_action(self, ok):
        if self.custom_c:
            self.bad_c.custom(ok)  # Works!
        else:
            self.default_check(ok)  # default check, if no custom code is provided

    # You can place any custom code into a function named "custom". The class will import this and use it whenever running your custom script.
    def default_check(ok):
        if ok:  # simple check
            print(f"{Fore.GREEN}[Debug]{Fore.RESET} Ok.")
        else:
            print(f"{Fore.GREEN}[Debug]{Fore.RESET} Fail.")

    def begin(self, sample_rate: int = 44100, duration: int = 10):
        record_thread = Thread(
            target=self.record_and_save,
            args=(
                duration,
                sample_rate,
            ),
        )  # create all the threads
        transcribe_thread = Thread(target=self.whisper_transcribe, args=())
        check_thread = Thread(target=self.check, args=())
        self.done = False
        self.ready = True  # record first
        self.check = False  # for checking the previous while recording the new one

        print(
            f"{Cursor.POS(1, 1)}Recording Stauts: {Fore.BLACK}{Back.RED}Idle{Fore.RESET}{Back.RESET}"
        )  # update status'
        print(
            f"{Cursor.POS(1, 2)}Whisper Stauts: {Fore.BLACK}{Back.RED}Idle{Fore.RESET}{Back.RESET}"
        )
        print(
            f"{Cursor.POS(1, 3)}Checker Stauts: {Fore.BLACK}{Back.RED}Idle{Fore.RESET}{Back.RESET}"
        )

        record_thread.start()  # start all the threads
        transcribe_thread.start()
        check_thread.start()

    def check(self):  # the thread that checks the transcribed audio
        transcribed = (
            self.transcribed
        )  # init vars 'cus I'm too lazy to add "self." to them
        bad_words_file = self.custom_file
        catch_reg = self.catch
        end_word = self.endphrase

        badwords = None
        try:
            badwordfile = open(bad_words_file, "r")
            badwords = badwordfile.read()
            badwordfile.close()
        except FileNotFoundError:
            print("File not found\nCreating one...")
            badwordfile = open(bad_words_file, "w")
            badwordfile.write("Default")
            badwordfile.close()

        if not badwords is None:  # init badwords
            badwords = badwords.split("\n")[0::-1]
        else:
            badwords = ["Default"]

        while self.Running:
            if self.check:
                try:
                    print(
                        f"{Cursor.POS(1, 3)}Checker Stauts: {Fore.BLACK}{Back.GREEN}Checking{Fore.RESET}{Back.RESET}"
                    )  # update status

                    lower_transcribed = transcribed.lower()
                    for i in range(0, len(badwords)):
                        try:  # if bad word is found
                            if catch_reg:  # if fuzzy mode
                                lower_transcribed.index(
                                    badwords[i]
                                )  # try to index the bad word
                            else:  # if not fuzzy mode
                                lower_transcribed.index(
                                    " " + badwords[i] + " "
                                )  # try to index the bad word as its own word
                            self.bad_word_action(False)
                            """
                            else:  # if not fuzzy
                                if lower_transcribed[result -
                                                     1] == ' ' and lower_transcribed[
                                                         result + len(badwords[i])] == ' ': # if the characters before and after the word are spaces
                                    self.bad_word_action(False)
                                else:  # else, if either of the characters are not spaces (which would make the current indexed word not its own word)
                                    #print(
                                    #    f"{Back.RED}{Fore.WHITE}Index: {result} -> {transcribed}{Back.RESET}{Fore.RESET}\n      {' ' * len(str(result))}     {' ' * result}^"
                                    #) # too beautifull to remove
                                    self.bad_word_action(True)
                            """
                        except (
                            ValueError,
                            IndexError,
                        ):  # if the index fails or if the non-fuzzy mode check fails
                            self.bad_word_action(True)
                        try:
                            lower_transcribed.index(end_word)
                            print(
                                f"{Fore.BLACK}{Back.GREEN}Ending words detected. Exiting gracefully.{Fore.RESET}{Back.RESET}"  # exit if we detect the ending words
                            )
                            self.Running = False
                            exit(1)
                        except ValueError:
                            continue
                    self.check = False
                    print(
                        f"{Cursor.POS(1, 2)}Checker Stauts: {Fore.BLACK}{Back.RED}Idle{Fore.RESET}{Back.RESET}       "
                    )
                except Exception as e:
                    self.Running = False
                    print(
                        f"{Cursor.POS(1, 4)}Whisper: {e}\n({traceback.format_exc().strip()})"
                    )
                    exit(1)
        print(Cursor.POS(1, 4))
